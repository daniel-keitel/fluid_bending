#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_debug_printf : enable

#include "util.glsl"

const int local_size = 4;
const int max_particles_per_cell = 16;

const uint group_mem_size = local_size*local_size*local_size*max_particles_per_cell;

const int neighbourhood_offset = (local_size-2)*(local_size-2)*(local_size-2)*max_particles_per_cell;

layout (local_size_x = local_size, local_size_y = local_size, local_size_z = local_size) in;

layout (std430, set = 0, binding = 0) uniform UniformBuffer {
    uniform_data uni;
};

layout (std430, set = 1, binding = 0) uniform ComputeUniformBuffer {
    compute_uniform_data cUni;
};

layout (scalar, set = 2, binding = 0) restrict readonly buffer HeadGridIn{
    int next_insert_adress_in;
    int head_grid_in[];
};

layout (scalar, set = 2, binding = 1) restrict readonly buffer ParticleMemoryIn{
    Particle particle_memory_in[];
};

layout (scalar, set = 2, binding = 2) restrict writeonly buffer HeadGridOut{ //initialized with -1
    int next_insert_adress_out;
    int head_grid_out[];
};

layout (scalar, set = 2, binding = 3) restrict writeonly buffer ParticleMemoryOut{
    Particle particle_memory_out[];
};

layout (scalar, set = 2, binding = 4) restrict readonly buffer ForceField{
    vec4 force_field[];
};

shared CoreParticle group_mem[group_mem_size];

shared int group_insert_ptr[2];

int local_hood_insert_ptr;
int local_neighboorhood_insert_ptr;

// useless "optimisation"
bool isHoodEmpty(){
    ivec3 base_pos = ivec3(gl_WorkGroupID * 2);
    uint cps = cUni.particle_cells_per_side;
    uint cps2 = cps * cps;
    uint base_index = base_pos.z * cps2 +
                      base_pos.y * cps +
                      base_pos.x;

    return (
        -1 == head_grid_in[base_index] &&
        -1 == head_grid_in[base_index+1] &&
        -1 == head_grid_in[base_index+cps] &&
        -1 == head_grid_in[base_index+cps+1] &&
        -1 == head_grid_in[base_index+cps2] &&
        -1 == head_grid_in[base_index+cps2+1] &&
        -1 == head_grid_in[base_index+cps2+cps] &&
        -1 == head_grid_in[base_index+cps2+cps+1]
    );
}

void buildLocalStructure(){
    if(gl_LocalInvocationIndex == 0){
        group_insert_ptr[1] = neighbourhood_offset;
        group_insert_ptr[0] = neighbourhood_offset-1;
    }
    barrier();

    const bool border_invocation = (
        gl_GlobalInvocationID.x == 0 || gl_GlobalInvocationID.x >= gl_WorkGroupSize.x*gl_NumWorkGroups.x-1 ||
        gl_GlobalInvocationID.y == 0 || gl_GlobalInvocationID.y >= gl_WorkGroupSize.y*gl_NumWorkGroups.y-1 ||
        gl_GlobalInvocationID.z == 0 || gl_GlobalInvocationID.z >= gl_WorkGroupSize.z*gl_NumWorkGroups.z-1
    );

    if(!border_invocation) {
        const ivec3 cell_pos = ivec3(gl_LocalInvocationID + gl_WorkGroupID * 2) - 1;
        const uint index = cell_pos.z * cUni.particle_cells_per_side * cUni.particle_cells_per_side +
                     cell_pos.y * cUni.particle_cells_per_side +
                     cell_pos.x;

        const int hood = int(
            gl_LocalInvocationID.x > 0 && gl_LocalInvocationID.x < gl_WorkGroupSize.x-1 &&
            gl_LocalInvocationID.y > 0 && gl_LocalInvocationID.y < gl_WorkGroupSize.y-1 &&
            gl_LocalInvocationID.z > 0 && gl_LocalInvocationID.z < gl_WorkGroupSize.z-1
        );

        int head = head_grid_in[index];
        while (head >= 0) {
            const Particle p = particle_memory_in[head];
            head = p.next;
            const int group_adress = atomicAdd(group_insert_ptr[1-hood], 1-2*hood);
            if (group_adress < 0 || group_adress >= group_mem_size)
                break;
            group_mem[group_adress] = p.core;

        }

        //debugPrintfEXT("[%v3i | %v3i]: cell: %v3i hood:%i adds:%i \\n" , gl_WorkGroupID, gl_LocalInvocationID, cell_pos, hood, adds);
    }
    barrier();

    local_hood_insert_ptr = max(-1, group_insert_ptr[0]);
    local_neighboorhood_insert_ptr = min(int(group_mem_size), group_insert_ptr[1]);
}

void insertParticle(Particle p){
    ivec3 cell_pos = min(ivec3(p.core.pos * cUni.particle_cells_per_side),ivec3(cUni.particle_cells_per_side-1));
    uint index = cell_pos.z * cUni.particle_cells_per_side*cUni.particle_cells_per_side +
    cell_pos.y * cUni.particle_cells_per_side +
    cell_pos.x;

    int insert_address = 1+atomicAdd(next_insert_adress_out,1);
    int last_head = atomicExchange(head_grid_out[index], insert_address);

    p.next = last_head;
    particle_memory_out[insert_address] = p;
}


ivec2 getThreadOperationRange(){
    int number_of_hood_particles = neighbourhood_offset - local_hood_insert_ptr - 1;
    int number_of_group_threads = local_size*local_size*local_size;
    int worker_index = int(gl_LocalInvocationIndex);

    int min_tasks_per_worker = number_of_hood_particles/number_of_group_threads;
    int remaining_tasks = number_of_hood_particles%number_of_group_threads;


    int extra_work_flag = int(worker_index < remaining_tasks);
    return ivec2((min_tasks_per_worker+extra_work_flag)*worker_index,
                 (min_tasks_per_worker+extra_work_flag)*(worker_index+1)) +
           (1-extra_work_flag) * ivec2(remaining_tasks);

//    if(worker_index < remaining_tasks){
//        return ivec2((min_tasks_per_worker+1)*worker_index,
//                     (min_tasks_per_worker+1)*(worker_index+1));
//    }else{
//        return ivec2(min_tasks_per_worker*worker_index,
//                     min_tasks_per_worker*(worker_index+1)) + ivec2(remaining_tasks);
//    }
}

const float mass = 0.1;

void integrate(inout CoreParticle p, vec3 force){
    //TODO implement better integrator
    //symplectic Euler
    p.vel.xyz += (force / mass) * uni.sim.step_size;
    p.pos.xyz += p.vel.xyz * uni.sim.step_size;
}

void constaint(inout CoreParticle p){
    if(p.pos.x < 0.0){
        p.pos.x = 0.0;
        p.vel.x = 0.0;
    }
    if(p.pos.y < 0.0){
        p.pos.y += 1.0; //teleport back up
        p.vel.y *= 0.5 ;
    }
    if(p.pos.y < 0.0){
        p.pos.y = 0.0;
        p.vel.y = 0.0;
    }
    if(p.pos.z < 0.0){
        p.pos.z = 0.0;
        p.vel.z = 0.0;
    }

    if(p.pos.x > 1.0){
        p.pos.x = 1.0;
        p.vel.x = 0.0;
    }
    if(p.pos.y > 1.0){
        p.pos.y -= 1.0; //teleport back down
        p.vel.y *= 0.5 ;
    }
    if(p.pos.y > 1.0){
        p.pos.y = 1.0;
        p.vel.y = 0.0;
    }
    if(p.pos.z > 1.0){
        p.pos.z = 1.0;
        p.vel.z = 0.0;
    }
}

vec4 sampleForceField(uint frame, vec3 pos){

    uvec4 o = uvec4(1, cUni.side_force_field_size, cUni.side_force_field_size*cUni.side_force_field_size,
                          cUni.side_force_field_size*cUni.side_force_field_size*cUni.side_force_field_size);

    vec3 floating_id = clamp(pos,vec3(0),vec3(0.99999)) * (cUni.side_force_field_size-1);

    vec3 frac = fract(floating_id);

    uvec3 id = uvec3(floating_id);

    uint base_index = o.x * id.x + o.y * id.y + o.z * id.z + frame * o.w;

//    return force_field[base_index];
    return mix(
            mix(
                    mix(
                            force_field[base_index],
                            force_field[base_index+o.z],
                            frac.z
                    ),
                    mix(
                            force_field[base_index+o.y],
                            force_field[base_index+o.y+o.z],
                            frac.z
                    ),
                    frac.y
            ),
            mix(
                    mix(
                            force_field[base_index+o.x],
                            force_field[base_index+o.x+o.z],
                            frac.z
                    ),
                    mix(
                            force_field[base_index+o.x+o.y],
                            force_field[base_index+o.x+o.y+o.z],
                            frac.z
                    ),
                    frac.y
            ),
            frac.x
    );

}


vec3 getExternalForce(Particle p){
    return sampleForceField(int(uni.sim.force_field_animation_index), p.core.pos).xyz * mass;
}

void work(inout Particle p){
    //TODO
    vec3 force = vec3(0);
    float dummy = 0;
    for(int i = local_hood_insert_ptr+1; i < local_neighboorhood_insert_ptr; i++){
        float dist = distance(p.core.pos, group_mem[i].pos);
        const float max_dist = 1.0/128.0;
        if(dist < max_dist){
            dummy += (max_dist-dist);
        }
    }
    p.debug = vec3(1,clamp(dummy*50.0,0.0,1.0),0);
    force += getExternalForce(p);
    integrate(p.core,force);
    constaint(p.core);
}


void main(){
    buildLocalStructure();

    ivec2 task_range = getThreadOperationRange();
    int not = task_range.y - task_range.x;

    int number_of_hood_particles = neighbourhood_offset - local_hood_insert_ptr - 1;
    //if(number_of_hood_particles > 0 && gl_LocalInvocationID == uvec3(0))
    //    debugPrintfEXT("[%v3i | %v3i]: %i \\n" , gl_WorkGroupID, gl_LocalInvocationID, number_of_hood_particles);
    //if(not > 0)
    //    debugPrintfEXT("[%v3i | %v3i]: %v2i, %i, work \\n" , gl_WorkGroupID, gl_LocalInvocationID, task_range, not);
    for(int i = task_range.x; i < task_range.y; i++){
        CoreParticle core_particle = group_mem[local_hood_insert_ptr + i + 1];
        Particle p;
        p.core = core_particle;
//        if(gl_WorkGroupID == uvec3(0)){
//            debugPrintfEXT("%i, hood_particles:%i, ptr:%i, offset:%i, %v3f\\n", i, number_of_hood_particles, local_hood_insert_ptr, neighbourhood_offset,  p.core.pos);
//        }
        work(p);
        //debugPrintfEXT("[%v3i | %v3i]: %v3f\\n" , gl_WorkGroupID, gl_LocalInvocationID, p.core.pos);
        insertParticle(p);
    }

}