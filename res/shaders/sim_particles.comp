#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_debug_printf : enable

#include "util.glsl"
#include "kernel.glsl"

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout (std430, set = 0, binding = 0) uniform UniformBuffer {
    uniform_data uni;
};

layout (std430, set = 1, binding = 0) uniform ComputeUniformBuffer {
    compute_uniform_data cUni;
};

layout (scalar, set = 2, binding = 0) restrict readonly buffer HeadGridIn{
    int next_insert_adress_in;
    int head_grid_in[];
};

layout (scalar, set = 2, binding = 1) restrict readonly buffer ParticleMemoryIn{
    Particle particle_memory_in[];
};

layout (scalar, set = 2, binding = 2) restrict writeonly buffer HeadGridOut{ //initialized with -1
    int next_insert_adress_out;
    int head_grid_out[];
};

layout (scalar, set = 2, binding = 3) restrict writeonly buffer ParticleMemoryOut{
    Particle particle_memory_out[];
};

layout (scalar, set = 2, binding = 4) restrict readonly buffer ForceField{
    vec4 force_field[];
};

void insertParticle(Particle p){
    ivec3 cell_pos = min(ivec3(p.core.pos * cUni.particle_cells_per_side),ivec3(cUni.particle_cells_per_side-1));
    uint index = cell_pos.z * cUni.particle_cells_per_side*cUni.particle_cells_per_side +
    cell_pos.y * cUni.particle_cells_per_side +
    cell_pos.x;

    int insert_address = 1+atomicAdd(next_insert_adress_out,1);
    int last_head = atomicExchange(head_grid_out[index], insert_address);

    p.next = last_head;
    particle_memory_out[insert_address] = p;
}

void integrate(inout CoreParticle p, vec3 force){
    //TODO implement better integrator
    //symplectic Euler
    p.vel.xyz += (force / uni.fluid.particle_mass) * uni.sim.step_size;
    p.pos.xyz += p.vel.xyz * uni.sim.step_size;
}

void constaint(inout CoreParticle p) {
    float k = 0.1;
    
    if (p.pos.x < 0.0) {
        p.pos.x = 0.0;
        p.vel.x = max(abs(p.vel.x) * k, p.vel.x);
    }
    if (p.pos.y < 0.0) {
        p.pos.y = 0;
        p.vel.y = max(abs(p.vel.y) * k, p.vel.y);
    }
    if (p.pos.z < 0.0) {
        p.pos.z = 0.0;
        p.vel.z = max(abs(p.vel.z) * k, p.vel.z);
    }

    if (p.pos.x > 1.0) {
        p.pos.x = 1.0;
        p.vel.x = min(-abs(p.vel.x) * k, p.vel.x);
    }
    if (p.pos.y > 1.0) {
        p.pos.y = 1.0;
        p.vel.y = min(-abs(p.vel.y) * k, p.vel.y);
    }
    if (p.pos.z > 1.0) {
        p.pos.z = 1.0;
        p.vel.z = min(-abs(p.vel.z) * k, p.vel.z);
    }
}

vec4 sampleForceField(uint frame, vec3 pos) {
    uvec4 o = uvec4(1, cUni.side_force_field_size, cUni.side_force_field_size * cUni.side_force_field_size,
                          cUni.side_force_field_size * cUni.side_force_field_size * cUni.side_force_field_size);

    vec3 floating_id = clamp(pos, vec3(0), vec3(0.99999)) * (cUni.side_force_field_size - 1);
    vec3 frac = fract(floating_id);
    uvec3 id = uvec3(floating_id);
    uint base_index = o.x * id.x + o.y * id.y + o.z * id.z + frame * o.w;

    return mix(
        mix(
            mix(
                force_field[base_index],
                force_field[base_index+o.z],
                frac.z
            ),
            mix(
                force_field[base_index+o.y],
                force_field[base_index+o.y+o.z],
                frac.z
            ),
            frac.y
        ),
        mix(
            mix(
                force_field[base_index+o.x],
                force_field[base_index+o.x+o.z],
                frac.z
            ),
            mix(
                force_field[base_index+o.x+o.y],
                force_field[base_index+o.x+o.y+o.z],
                frac.z
            ),
            frac.y
        ),
        frac.x
    );
}

vec3 getExternalForce(Particle p) {
    return sampleForceField(uni.sim.force_field_animation_index, p.core.pos).xyz * uni.fluid.particle_mass;
}

float calcPressure(float density) {
    float k = uni.fluid.gas_stiffness;
    float gamma = uni.fluid.gamma;
    float rest_density = uni.fluid.rest_density;

    return max(((k * rest_density) / gamma) * (pow((density / rest_density), gamma) - 1.0), 0.0);
}

void main() {
    // only simulate existing particles
    if (gl_GlobalInvocationID.x >= next_insert_adress_in + 1)
        return;

    // each invocation simulates one particle
    Particle p = particle_memory_in[gl_GlobalInvocationID.x];

    // get the cell of the particle, needed to find neighbours
    ivec3 cell_pos = min(ivec3(p.core.pos * cUni.particle_cells_per_side),ivec3(cUni.particle_cells_per_side-1));

    int cell_index = 0;
    uint cell_indices[27];
    uint number_of_valid_cells = 0;

    // find all neigbouring cell indices and write them into array.
    //  this decouples these nested loops from the more lineare compute extensive execution flow for better SM utilisation
    for (int x = -1; x < 2; x++) {
        for (int y = -1; y < 2; y++) {
            for (int z = -1; z < 2; z++) {
                ivec3 current_cell_pos = cell_pos + ivec3(x,y,z);

                if (!(current_cell_pos.x >= 0 &&
                   current_cell_pos.y >= 0 &&
                   current_cell_pos.z >= 0 &&
                   current_cell_pos.x < cUni.particle_cells_per_side &&
                   current_cell_pos.y < cUni.particle_cells_per_side &&
                   current_cell_pos.z < cUni.particle_cells_per_side)) {
                    continue;
                }

                uint index = current_cell_pos.z * cUni.particle_cells_per_side*cUni.particle_cells_per_side +
                             current_cell_pos.y * cUni.particle_cells_per_side +
                             current_cell_pos.x;

                cell_indices[nonuniformEXT(number_of_valid_cells)] = index;
                number_of_valid_cells++;
            }
        }
    }

    // variables needed for the simulation
    vec3 force = vec3(0.0);
    vec3 pressure_gradient = vec3(0.0);
    vec3 viscocity_laplacian = vec3(0.0);

    int cell_counter = 0;
    int head = -1;

    // iterate over all neighbours
    while (true) {
        // if the cell is empty go to the next one until all neighbours are visited
        if (head == -1) {
            if (cell_counter >= number_of_valid_cells) {
                break;
            }
            head = head_grid_in[cell_indices[nonuniformEXT(cell_counter)]];
            cell_counter++;
            continue;
        }
        
        // retrive a neighbour and advance throug the linked list
        Particle neighbour = particle_memory_in[head];
        head = neighbour.next;

        float kernel_radius = uni.fluid.kernel_radius;
        vec3 dist_vec = neighbour.core.pos - p.core.pos;
        float dist = length(dist_vec);

        // skip own particle
        // TODO: Replace with real check
        if (dist == 0.0) continue;

        float density_particle = p.core.density;
        float density_neighbour = neighbour.core.density;

        float pressure_particle = calcPressure(density_particle);
        float pressure_neighbour = calcPressure(density_neighbour);

        vec3 velocity_particle = p.core.vel;
        vec3 velocity_neighbour = neighbour.core.vel;


        if (dist <= kernel_radius) {
            pressure_gradient += uni.fluid.particle_mass 
                * ((pressure_particle / pow(density_particle, 2)) + (pressure_neighbour / pow(density_neighbour, 2.0)))
                * kernelGradient(dist_vec, kernel_radius);

            viscocity_laplacian += (uni.fluid.particle_mass / density_neighbour)
                * (velocity_particle - velocity_neighbour) * normalize(dist_vec) * kernelGradient(dist_vec, kernel_radius);
        }
    }

    p.debug = vec3(1.0, clamp(50.0, 0.0, 1.0), 0.0);

    // Forces
    force += (uni.fluid.ext_force_multiplier * getExternalForce(p));
    if (uni.fluid.fluid_forces) {
        force -= pressure_gradient;

        if (uni.fluid.viscosity_forces) {
            force -= (uni.fluid.dynamic_viscosity / p.core.density) * viscocity_laplacian;
        }
    }

    integrate(p.core,force);
    
    // Constraints
    if (uni.fluid.apply_constraint) {
        constaint(p.core);
    }

    insertParticle(p);
}