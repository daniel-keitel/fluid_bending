#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_debug_printf : enable

#include "util.glsl"


layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout (std430, set = 0, binding = 0) uniform UniformBuffer {
    uniform_data uni;
};

layout (std430, set = 1, binding = 0) uniform ComputeUniformBuffer {
    compute_uniform_data cUni;
};

layout (scalar, set = 2, binding = 0) restrict readonly buffer HeadGridIn{
    int next_insert_adress_in;
    int head_grid_in[];
};

layout (scalar, set = 2, binding = 1) restrict readonly buffer ParticleMemoryIn{
    Particle particle_memory_in[];
};

layout (scalar, set = 2, binding = 2) restrict writeonly buffer HeadGridOut{ //initialized with -1
    int next_insert_adress_out;
    int head_grid_out[];
};

layout (scalar, set = 2, binding = 3) restrict writeonly buffer ParticleMemoryOut{
    Particle particle_memory_out[];
};

layout (scalar, set = 2, binding = 4) restrict readonly buffer ForceField{
    vec4 force_field[];
};



void insertParticle(Particle p){
    ivec3 cell_pos = ivec3(p.core.pos * cUni.particle_cells_per_side);
    uint index = cell_pos.z * cUni.particle_cells_per_side*cUni.particle_cells_per_side +
    cell_pos.y * cUni.particle_cells_per_side +
    cell_pos.x;

    int insert_address = 1+atomicAdd(next_insert_adress_out,1);
    int last_head = atomicExchange(head_grid_out[index], insert_address);

    p.next = last_head;
    particle_memory_out[insert_address] = p;
}

const float mass = 0.1;

void integrate(inout CoreParticle p, vec3 force){
    //TODO implement better integrator
    //symplectic Euler
    p.vel.xyz += (force / mass) * uni.sim.step_size;
    p.pos.xyz += p.vel.xyz * uni.sim.step_size;
}

void constaint(inout CoreParticle p){
    if(p.pos.x < 0.0){
        p.pos.x = 0.0;
        p.vel.x = 0.0;
    }
    if(p.pos.y < 0.0){
        p.pos.y += 1.0; //teleport back up
        p.vel.y *= 0.5 ;
    }
    if(p.pos.y < 0.0){
        p.pos.y = 0.0;
        p.vel.y = 0.0;
    }
    if(p.pos.z < 0.0){
        p.pos.z = 0.0;
        p.vel.z = 0.0;
    }

    if(p.pos.x > 1.0){
        p.pos.x = 1.0;
        p.vel.x = 0.0;
    }
    if(p.pos.y > 1.0){
        p.pos.y -= 1.0; //teleport back down
        p.vel.y *= 0.5 ;
    }
    if(p.pos.y > 1.0){
        p.pos.y = 1.0;
        p.vel.y = 0.0;
    }
    if(p.pos.z > 1.0){
        p.pos.z = 1.0;
        p.vel.z = 0.0;
    }
}

vec4 sampleForceField(uint frame, vec3 pos){

    uvec4 o = uvec4(1, cUni.side_force_field_size, cUni.side_force_field_size*cUni.side_force_field_size,
                          cUni.side_force_field_size*cUni.side_force_field_size*cUni.side_force_field_size);

    vec3 floating_id = clamp(pos,vec3(0),vec3(0.99999)) * (cUni.side_force_field_size-1);

    vec3 frac = fract(floating_id);

    uvec3 id = uvec3(floating_id);

    uint base_index = o.x * id.x + o.y * id.y + o.z * id.z + frame * o.w;

//    return force_field[base_index];
    return mix(
            mix(
                    mix(
                            force_field[base_index],
                            force_field[base_index+o.z],
                            frac.z
                    ),
                    mix(
                            force_field[base_index+o.y],
                            force_field[base_index+o.y+o.z],
                            frac.z
                    ),
                    frac.y
            ),
            mix(
                    mix(
                            force_field[base_index+o.x],
                            force_field[base_index+o.x+o.z],
                            frac.z
                    ),
                    mix(
                            force_field[base_index+o.x+o.y],
                            force_field[base_index+o.x+o.y+o.z],
                            frac.z
                    ),
                    frac.y
            ),
            frac.x
    );

}


vec3 getExternalForce(Particle p){
    return sampleForceField(uni.sim.force_field_animation_index, p.core.pos).xyz * mass;
}

void main(){
    // ownly simulate existing particles
    if(gl_GlobalInvocationID.x >= next_insert_adress_in)
        return;

    // each invocation simulates one particle
    Particle p = particle_memory_in[gl_GlobalInvocationID.x];

    // get the cell of the particle, needed to find neighbours
    ivec3 cell_pos = ivec3(p.core.pos * cUni.particle_cells_per_side);

    int cell_index = 0;
    uint cell_indices[27];
    uint number_of_valid_cells = 0;

    // find all neigbouring cell indices and write them into array.
    //  this decouples these nested loops from the more lineare compute extensive execution flow for better SM utilisation
    for(int x = -1; x < 2; x++){
        for(int y = -1; y < 2; y++){
            for(int z = -1; z < 2; z++){
                ivec3 current_cell_pos = cell_pos + ivec3(x,y,z);
                if(!(current_cell_pos.x >= 0 &&
                   current_cell_pos.y >= 0 &&
                   current_cell_pos.z >= 0 &&
                   current_cell_pos.x < cUni.particle_cells_per_side &&
                   current_cell_pos.y < cUni.particle_cells_per_side &&
                   current_cell_pos.z < cUni.particle_cells_per_side)){
                    continue;
                }
                uint index = current_cell_pos.z * cUni.particle_cells_per_side*cUni.particle_cells_per_side +
                             current_cell_pos.y * cUni.particle_cells_per_side +
                             current_cell_pos.x;
                cell_indices[nonuniformEXT(number_of_valid_cells)] = index;
                number_of_valid_cells++;
            }
        }
    }

    // TODO variables needed for the simulation
    vec3 force = vec3(0);
    float dummy = 0;

    int cell_counter = 0;
    int head = -1;
    // iterate over all neighbours
    while(true){
        // if the cell is empty go to the next one until all neighbours are visited
        if(head == -1){
            if(cell_counter >= number_of_valid_cells){
                break;
            }
            head = head_grid_in[cell_indices[nonuniformEXT(cell_counter)]];
            cell_counter++;
            continue;
        }
        // retrive a neighbour and advance throug the linked list
        Particle neighbour = particle_memory_in[head];
        head = neighbour.next;

        // TODO do something with the neighbour data
        float dist = distance(p.core.pos, neighbour.core.pos);
        const float max_dist = 1.0/128.0;
        if(dist < max_dist){
            dummy += (max_dist-dist);
        }

    }

    // TODO update particle and write to memory
    p.debug = vec3(1,clamp(dummy*50.0,0.0,1.0),0);
    force += getExternalForce(p);
    integrate(p.core,force);
    constaint(p.core);
    insertParticle(p);

}